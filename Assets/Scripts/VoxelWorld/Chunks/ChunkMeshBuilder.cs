using System;
using UnityEngine;
using Utils;
using VoxelWorld.Blocks;

namespace VoxelWorld.Chunks
{
	public class ChunkMeshBuilder
	{
		public event Action OnMeshInvalidated;

		private readonly BlockService blockService;

		private readonly Chunk chunk;

		private readonly int[] chunkSize;
		private readonly int[] minCoordinate;
		private readonly int[] maxCoordinate;

		private readonly ChunkMeshModel cutoutMeshBuffer;
		private readonly ChunkMeshModel transparentMeshBuffer;
		private readonly ChunkMeshModel collisionMeshBuffer;

		private Vector3[] faceVerticesArrayBuffer;
		private Vector2[] faceUVsArrayBuffer;

		private BlockModel blockModelBuffer;
		private BlockModel neighborBlockModelBuffer;

		private bool meshInvalidated;

		public ChunkMeshBuilder(in Chunk chunk, byte subdivisionIndex)
		{
			blockService = BlockService.Instance;

			this.chunk = chunk;

			Vector3Int subChunkBlockPositionOffset = chunk.GetSize().y / chunk.GetSubdivisionCount() * subdivisionIndex * Vector3Int.up;

			Vector3Int subChunkSize = chunk.GetSize();
			subChunkSize.y /= chunk.GetSubdivisionCount();

			chunkSize = new[] { this.chunk.GetSize().x, this.chunk.GetSize().y, this.chunk.GetSize().z };

			minCoordinate = new[] { subChunkBlockPositionOffset.x, subChunkBlockPositionOffset.y, subChunkBlockPositionOffset.z };
			maxCoordinate = new[] { subChunkBlockPositionOffset.x + subChunkSize.x, subChunkBlockPositionOffset.y + subChunkSize.y, subChunkBlockPositionOffset.z + subChunkSize.z };

			cutoutMeshBuffer = new ChunkMeshModel();
			transparentMeshBuffer = new ChunkMeshModel();
			collisionMeshBuffer = new ChunkMeshModel();

			faceVerticesArrayBuffer = BlockMeshModel.AllocateFaceVerticesArray();
			faceUVsArrayBuffer = BlockMeshModel.AllocateFaceUVsArray();
		}

		public void InvalidateMesh()
		{
			meshInvalidated = true;
			OnMeshInvalidated?.Invoke();
		}

		public Mesh[] GetMesh()
		{
			if (meshInvalidated)
				BuildMesh();
			return new[] { cutoutMeshBuffer.GetMesh(), transparentMeshBuffer.GetMesh(), collisionMeshBuffer.GetMesh() };
		}

		//this method is performance-critical. Heap alloc and stack frames generated by this method are minimized to make it run faster.
		private void BuildMesh()
		{
			cutoutMeshBuffer.Clear();
			transparentMeshBuffer.Clear();
			collisionMeshBuffer.Clear();

			// using three loops here is significantly more performant than using a coordinate iterator
			for (int y = minCoordinate[1]; y < maxCoordinate[1]; y++)
			{
				for (int z = minCoordinate[2]; z < maxCoordinate[2]; z++)
				{
					for (int x = minCoordinate[0]; x < maxCoordinate[0]; x++)
					{
						byte block = chunk.GetBlockAtLocalPosition(in x, in y, in z);
						if (block == 0) continue;

						for (int i = 0; i < BlockMeshModel.FaceNormals.Length; i++)
						{
							int neighborPosX = x + BlockMeshModel.FaceNormals[i].x;
							int neighborPosY = y + BlockMeshModel.FaceNormals[i].y;
							int neighborPosZ = z + BlockMeshModel.FaceNormals[i].z;
							Chunk neighborChunk = chunk;

							int neighborBlock = -1;

							if (neighborPosY >= 0 && neighborPosY < chunkSize[1])
							{
								if (neighborPosX < 0)
									neighborChunk = chunk.GetNeighbor(2);
								else if (neighborPosX >= chunkSize[0])
									neighborChunk = chunk.GetNeighbor(0);
								else if (neighborPosZ < 0)
									neighborChunk = chunk.GetNeighbor(1);
								else if (neighborPosZ >= chunkSize[2])
									neighborChunk = chunk.GetNeighbor(3);

								if (neighborChunk == chunk)
								{
									neighborBlock = chunk.GetBlockAtLocalPosition(neighborPosX, neighborPosY, neighborPosZ);
								}
								else if (neighborChunk != null)
								{
									neighborBlock = neighborChunk.GetBlockAtLocalPosition(
										MathUtils.Mod(neighborPosX, chunkSize[0]),
										neighborPosY,
										MathUtils.Mod(neighborPosZ, chunkSize[2])
									);
								}
							}

							if (blockModelBuffer == null || blockModelBuffer.Id != block)
								blockModelBuffer = blockService.GetBlockModel(block);

							if (neighborBlock > 0)
							{

								if (neighborBlock == block)
								{
									if (blockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
								else
								{
									if (neighborBlockModelBuffer == null || neighborBlockModelBuffer.Id != neighborBlock)
										neighborBlockModelBuffer = blockService.GetBlockModel(neighborBlock);

									if (neighborBlockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
							}



							ChunkMeshModel activeMeshBuffer = blockModelBuffer.RenderType == RenderType.Transparent
								? transparentMeshBuffer
								: cutoutMeshBuffer;

							BlockMeshModel.GetFaceVerticesInWorldSpace(x, y, z, i, ref faceVerticesArrayBuffer);
							activeMeshBuffer.AddVertices(faceVerticesArrayBuffer);

							BlockMeshModel.GetFaceUVs(blockModelBuffer.TextureIndexes[i], ref faceUVsArrayBuffer);
							activeMeshBuffer.AddUVs(faceUVsArrayBuffer);

							activeMeshBuffer.GetVertexCount(out int activeMeshBufferVertexCount);
							for (int j = 0; j < BlockMeshModel.FaceTriangleOrder.Length; j++)
							{
								activeMeshBuffer.AddTriangle(activeMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
							}

							if (blockModelBuffer.Solid)
							{
								collisionMeshBuffer.AddVertices(faceVerticesArrayBuffer);

								collisionMeshBuffer.GetVertexCount(out int collisionMeshBufferVertexCount);
								for (int j = 0; j < BlockMeshModel.FaceTriangleOrder.Length; j++)
								{
									collisionMeshBuffer.AddTriangle(collisionMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
								}
							}
							else
							{
								// non solid blocks are double-sided
								activeMeshBuffer.AddVertices(faceVerticesArrayBuffer);

								activeMeshBuffer.AddUVs(faceUVsArrayBuffer);

								activeMeshBuffer.GetVertexCount(out activeMeshBufferVertexCount);
								for (int j = BlockMeshModel.FaceTriangleOrder.Length - 1; j >= 0; j--)
								{
									activeMeshBuffer.AddTriangle(activeMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
								}

							}
						}
					}
				}
			}

			cutoutMeshBuffer.Rebuild();
			transparentMeshBuffer.Rebuild();
			collisionMeshBuffer.Rebuild();

			meshInvalidated = false;
		}
	}
}
