using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Utils;
using VoxelWorld.Blocks;

namespace VoxelWorld.Chunks
{
	public class SubChunk
	{
		public event Action OnMeshInvalidated;

		private readonly Chunk chunk;
		private readonly byte subdivisionIndex;
		private readonly Vector3Int offset;
		private readonly Vector3Int size;

		private readonly BlockService blockService;

		private bool meshInvalidated;

		private Vector3[] faceVerticesArrayBuffer;
		private Vector2[] faceUVsArrayBuffer;
		private readonly Mesh meshBuffer;
		private readonly List<Vector3> verticesBuffer;
		private readonly List<int> trianglesBuffer;
		private readonly List<Vector2> uvsBuffer;

		private readonly int[] itrOffset;
		private readonly int[] itrTarget;

		private readonly int[] chunkSizeBuffer;

		private BlockModel blockModelBuffer;
		private BlockModel neighborBlockModelBuffer;

		public SubChunk(in Chunk chunk, byte subdivisionIndex)
		{
			this.blockService = BlockService.Instance;

			this.chunk = chunk;
			this.subdivisionIndex = subdivisionIndex;

			this.offset = chunk.GetSize().y / chunk.GetSubdivisionCount() *
			              this.subdivisionIndex * Vector3Int.up;

			this.size = chunk.GetSize();
			this.size.y /= chunk.GetSubdivisionCount();


			this.faceVerticesArrayBuffer = this.blockService.GetFaceVerticesArrayBuffer();
			this.faceUVsArrayBuffer = this.blockService.GetFaceUVsArrayBuffer();

			this.meshBuffer = new Mesh();

			this.verticesBuffer = new List<Vector3>(5000);
			this.trianglesBuffer = new List<int>(5000);
			this.uvsBuffer = new List<Vector2>(5000);
			
			this.itrOffset = new[] { this.offset.x, this.offset.y, this.offset.z };
			this.itrTarget = new[] { this.offset.x + this.size.x, this.offset.y + this.size.y, this.offset.z + this.size.z };

			this.chunkSizeBuffer = new[] {this.chunk.GetSize().x, this.chunk.GetSize().y, this.chunk.GetSize().z};
		}

		public Chunk GetChunk() => this.chunk;

		public byte GetSubdivisionIndex() => this.subdivisionIndex;

		public CoordinateIterator GetLocalSpaceIterator()
		{
			return new CoordinateIterator(this.size, this.offset);
		}

		public CoordinateIterator GetWorldSpaceIterator()
		{
			Vector2Int chunkPos = this.chunk.GetWorldSpacePosition();
			return new CoordinateIterator(this.size, new Vector3Int(chunkPos.x, this.offset.y, chunkPos.y));
		}

		public void InvalidateMesh()
		{
			this.meshInvalidated = true;
			OnMeshInvalidated?.Invoke();
		}

		public Mesh GetMesh()
		{
			if (this.meshInvalidated)
				GenerateMesh();
			return this.meshBuffer;
		}

		//this method is performance-critical. Heap alloc and stack frames generated by this method are minimized to make it run faster.
		private void GenerateMesh()
		{
			this.meshBuffer.Clear();
			this.verticesBuffer.Clear();
			this.trianglesBuffer.Clear();
			this.uvsBuffer.Clear();
			
			for (int y = this.itrOffset[1]; y < this.itrTarget[1]; y++)
			{
				for (int z = this.itrOffset[2]; z < this.itrTarget[2]; z++)
				{
					for (int x = this.itrOffset[0]; x < this.itrTarget[0]; x++)
					{
						byte block = this.chunk.GetBlockAtLocalPosition(in x, in y, in z);
						if (block == 0) continue;

						for (int i = 0; i < BlockService.FaceOrder.Length; i++)
						{
							int neighborPosX = x + BlockService.FaceOrderArr[i][0];
							int neighborPosY = y + BlockService.FaceOrderArr[i][1];
							int neighborPosZ = z + BlockService.FaceOrderArr[i][2];
							Chunk neighborChunk = this.chunk;

							int neighborBlock = -1;

							if (neighborPosY >= 0 && neighborPosY < this.chunkSizeBuffer[1])
							{
								if (neighborPosX < 0)
									neighborChunk = this.chunk.GetNeighbor(2);
								else if (neighborPosX >= this.chunkSizeBuffer[0])
									neighborChunk = this.chunk.GetNeighbor(0);
								else if (neighborPosZ < 0)
									neighborChunk = this.chunk.GetNeighbor(1);
								else if (neighborPosZ >= this.chunkSizeBuffer[2])
									neighborChunk = this.chunk.GetNeighbor(3);

								if (neighborChunk == this.chunk)
								{
									neighborBlock = this.chunk.GetBlockAtLocalPosition(neighborPosX, neighborPosY, neighborPosZ);
								}
								else if (neighborChunk != null)
								{
									neighborBlock = neighborChunk.GetBlockAtLocalPosition(
										MathUtils.Mod(neighborPosX, this.chunkSizeBuffer[0]),
										neighborPosY,
										MathUtils.Mod(neighborPosZ, this.chunkSizeBuffer[2])
									);
								}
							}

							if (neighborBlock > 0)
							{
								if (blockModelBuffer == null || blockModelBuffer.Id != block)
									this.blockModelBuffer = this.blockService.GetBlockModel(block);

								if (neighborBlock == block)
								{
									if (!blockModelBuffer.Transparent || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
								else
								{
									if (neighborBlockModelBuffer == null || neighborBlockModelBuffer.Id != neighborBlock)
										this.neighborBlockModelBuffer = this.blockService.GetBlockModel(neighborBlock);

									if (!neighborBlockModelBuffer.Transparent || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
							}

							this.blockService.GetFaceVertices(x, y, z, i, ref faceVerticesArrayBuffer);
							verticesBuffer.AddRange(faceVerticesArrayBuffer);

							foreach (byte id in BlockService.FaceTriangleOrder)
								trianglesBuffer.Add(verticesBuffer.Count - 1 - id);

							this.blockService.GetFaceUVs(block, i, ref faceUVsArrayBuffer);
							uvsBuffer.AddRange(faceUVsArrayBuffer);
						}
					}
				}
			}

			meshBuffer.vertices = verticesBuffer.ToArray();
			meshBuffer.triangles = trianglesBuffer.ToArray();
			meshBuffer.uv = uvsBuffer.ToArray();
			meshBuffer.RecalculateNormals();
			meshBuffer.RecalculateTangents();

			this.meshInvalidated = false;
		}
	}
}