using System;
using UnityEngine;
using Utils;
using VoxelWorld.Blocks;
using VoxelWorld.Chunks;

namespace VoxelWorld.Renderers
{
	public class ChunkRenderer
	{
		public event Action OnMeshInvalidated;

		private readonly Chunk chunk;

		private readonly BlockService blockService;

		private bool meshInvalidated;

		private Vector3[] faceVerticesArrayBuffer;
		private Vector2[] faceUVsArrayBuffer;

		private readonly int[] min;
		private readonly int[] max;

		private readonly int[] chunkSizeBuffer;

		private BlockModel blockModelBuffer;
		private BlockModel neighborBlockModelBuffer;

		private readonly MeshBuffer cutoutMeshBuffer;
		private readonly MeshBuffer transparentMeshBuffer;
		private readonly MeshBuffer collisionMeshBuffer;

		public ChunkRenderer(in Chunk chunk, byte subdivisionIndex)
		{
			this.blockService = BlockService.Instance;

			this.chunk = chunk;

			Vector3Int subChunkBlockPositionOffset = chunk.GetSize().y / chunk.GetSubdivisionCount() * subdivisionIndex * Vector3Int.up;

			Vector3Int subChunkSize = chunk.GetSize();
			subChunkSize.y /= chunk.GetSubdivisionCount();

			this.min = new[] { subChunkBlockPositionOffset.x, subChunkBlockPositionOffset.y, subChunkBlockPositionOffset.z };
			this.max = new[] { subChunkBlockPositionOffset.x + subChunkSize.x, subChunkBlockPositionOffset.y + subChunkSize.y, subChunkBlockPositionOffset.z + subChunkSize.z };


			this.faceVerticesArrayBuffer = this.blockService.GetFaceVerticesArrayBuffer();
			this.faceUVsArrayBuffer = this.blockService.GetFaceUVsArrayBuffer();

			this.cutoutMeshBuffer = new MeshBuffer();
			this.transparentMeshBuffer = new MeshBuffer();
			this.collisionMeshBuffer = new MeshBuffer();

			this.chunkSizeBuffer = new[] { this.chunk.GetSize().x, this.chunk.GetSize().y, this.chunk.GetSize().z };
		}

		public void InvalidateMesh()
		{
			this.meshInvalidated = true;
			OnMeshInvalidated?.Invoke();
		}

		public Mesh[] GetMesh()
		{
			if (this.meshInvalidated)
				GenerateMesh();
			return new[] { this.cutoutMeshBuffer.GetMesh(), this.transparentMeshBuffer.GetMesh(), this.collisionMeshBuffer.GetMesh() };
		}

		//this method is performance-critical. Heap alloc and stack frames generated by this method are minimized to make it run faster.
		private void GenerateMesh()
		{
			this.cutoutMeshBuffer.Clear();
			this.transparentMeshBuffer.Clear();
			this.collisionMeshBuffer.Clear();

			for (int y = this.min[1]; y < this.max[1]; y++)
			{
				for (int z = this.min[2]; z < this.max[2]; z++)
				{
					for (int x = this.min[0]; x < this.max[0]; x++)
					{
						byte block = this.chunk.GetBlockAtLocalPosition(in x, in y, in z);
						if (block == 0) continue;

						for (int i = 0; i < BlockService.FaceOrder.Length; i++)
						{
							int neighborPosX = x + BlockService.FaceOrderArr[i][0];
							int neighborPosY = y + BlockService.FaceOrderArr[i][1];
							int neighborPosZ = z + BlockService.FaceOrderArr[i][2];
							Chunk neighborChunk = this.chunk;

							int neighborBlock = -1;

							if (neighborPosY >= 0 && neighborPosY < this.chunkSizeBuffer[1])
							{
								if (neighborPosX < 0)
									neighborChunk = this.chunk.GetNeighbor(2);
								else if (neighborPosX >= this.chunkSizeBuffer[0])
									neighborChunk = this.chunk.GetNeighbor(0);
								else if (neighborPosZ < 0)
									neighborChunk = this.chunk.GetNeighbor(1);
								else if (neighborPosZ >= this.chunkSizeBuffer[2])
									neighborChunk = this.chunk.GetNeighbor(3);

								if (neighborChunk == this.chunk)
								{
									neighborBlock = this.chunk.GetBlockAtLocalPosition(neighborPosX, neighborPosY, neighborPosZ);
								}
								else if (neighborChunk != null)
								{
									neighborBlock = neighborChunk.GetBlockAtLocalPosition(
										MathUtils.Mod(neighborPosX, this.chunkSizeBuffer[0]),
										neighborPosY,
										MathUtils.Mod(neighborPosZ, this.chunkSizeBuffer[2])
									);
								}
							}

							if (blockModelBuffer == null || blockModelBuffer.Id != block)
								this.blockModelBuffer = this.blockService.GetBlockModel(block);

							if (neighborBlock > 0)
							{

								if (neighborBlock == block)
								{
									if (blockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
								else
								{
									if (neighborBlockModelBuffer == null || neighborBlockModelBuffer.Id != neighborBlock)
										this.neighborBlockModelBuffer = this.blockService.GetBlockModel(neighborBlock);

									if (neighborBlockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
							}

							

							MeshBuffer activeMeshBuffer = blockModelBuffer.RenderType == RenderType.Transparent
								? this.transparentMeshBuffer
								: this.cutoutMeshBuffer;

							this.blockService.GetFaceVertices(x, y, z, i, ref faceVerticesArrayBuffer);
							activeMeshBuffer.AddVertices(faceVerticesArrayBuffer);

							activeMeshBuffer.GetVertexCount(out int activeMeshBufferVertexCount);
							for (int j = 0; j < BlockService.FaceTriangleOrder.Length; j++)
							{
								activeMeshBuffer.AddTriangle(activeMeshBufferVertexCount - 1 - BlockService.FaceTriangleOrder[j]);
							}

							this.blockService.GetFaceUVs(block, i, ref faceUVsArrayBuffer);
							activeMeshBuffer.AddUVs(faceUVsArrayBuffer);

							if (blockModelBuffer.Solid)
							{
								collisionMeshBuffer.AddVertices(faceVerticesArrayBuffer);

								collisionMeshBuffer.GetVertexCount(out int collisionMeshBufferVertexCount);
								for (int j = 0; j < BlockService.FaceTriangleOrder.Length; j++)
								{
									collisionMeshBuffer.AddTriangle(collisionMeshBufferVertexCount - 1 - BlockService.FaceTriangleOrder[j]);
								}
							}
						}
					}
				}
			}

			this.cutoutMeshBuffer.Rebuild();
			this.transparentMeshBuffer.Rebuild();
			this.collisionMeshBuffer.Rebuild();

			this.meshInvalidated = false;
		}
	}
}
