using System;
using UnityEngine;
using Utils;
using VoxelWorld.Blocks;
using VoxelWorld.Chunks;

namespace VoxelWorld.Renderers
{
	public class ChunkRenderer
	{
		public event Action OnMeshInvalidated;

		private readonly BlockService blockService;

		private readonly Chunk chunk;

		private readonly int[] chunkSize;
		private readonly int[] minCoordinate;
		private readonly int[] maxCoordinate;

		private readonly MeshBuffer cutoutMeshBuffer;
		private readonly MeshBuffer transparentMeshBuffer;
		private readonly MeshBuffer collisionMeshBuffer;

		private Vector3[] faceVerticesArrayBuffer;
		private Vector2[] faceUVsArrayBuffer;

		private BlockModel blockModelBuffer;
		private BlockModel neighborBlockModelBuffer;

		private bool meshInvalidated;

		public ChunkRenderer(in Chunk chunk, byte subdivisionIndex)
		{
			this.blockService = BlockService.Instance;

			this.chunk = chunk;

			Vector3Int subChunkBlockPositionOffset = chunk.GetSize().y / chunk.GetSubdivisionCount() * subdivisionIndex * Vector3Int.up;

			Vector3Int subChunkSize = chunk.GetSize();
			subChunkSize.y /= chunk.GetSubdivisionCount();

			this.chunkSize = new[] { this.chunk.GetSize().x, this.chunk.GetSize().y, this.chunk.GetSize().z };

			this.minCoordinate = new[] { subChunkBlockPositionOffset.x, subChunkBlockPositionOffset.y, subChunkBlockPositionOffset.z };
			this.maxCoordinate = new[] { subChunkBlockPositionOffset.x + subChunkSize.x, subChunkBlockPositionOffset.y + subChunkSize.y, subChunkBlockPositionOffset.z + subChunkSize.z };

			this.cutoutMeshBuffer = new MeshBuffer();
			this.transparentMeshBuffer = new MeshBuffer();
			this.collisionMeshBuffer = new MeshBuffer();

			this.faceVerticesArrayBuffer = BlockMeshModel.AllocateFaceVerticesArray();
			this.faceUVsArrayBuffer = BlockMeshModel.AllocateFaceUVsArray();
		}

		public void InvalidateMesh()
		{
			this.meshInvalidated = true;
			OnMeshInvalidated?.Invoke();
		}

		public Mesh[] GetMesh()
		{
			if (this.meshInvalidated)
				GenerateMesh();
			return new[] { this.cutoutMeshBuffer.GetMesh(), this.transparentMeshBuffer.GetMesh(), this.collisionMeshBuffer.GetMesh() };
		}

		//this method is performance-critical. Heap alloc and stack frames generated by this method are minimized to make it run faster.
		private void GenerateMesh()
		{
			this.cutoutMeshBuffer.Clear();
			this.transparentMeshBuffer.Clear();
			this.collisionMeshBuffer.Clear();

			// using three loops here is significantly more performant than using a coordinate iterator
			for (int y = this.minCoordinate[1]; y < this.maxCoordinate[1]; y++)
			{
				for (int z = this.minCoordinate[2]; z < this.maxCoordinate[2]; z++)
				{
					for (int x = this.minCoordinate[0]; x < this.maxCoordinate[0]; x++)
					{
						byte block = this.chunk.GetBlockAtLocalPosition(in x, in y, in z);
						if (block == 0) continue;

						for (int i = 0; i < BlockMeshModel.FaceNormals.Length; i++)
						{
							int neighborPosX = x + BlockMeshModel.FaceNormals[i].x;
							int neighborPosY = y + BlockMeshModel.FaceNormals[i].y;
							int neighborPosZ = z + BlockMeshModel.FaceNormals[i].z;
							Chunk neighborChunk = this.chunk;

							int neighborBlock = -1;

							if (neighborPosY >= 0 && neighborPosY < this.chunkSize[1])
							{
								if (neighborPosX < 0)
									neighborChunk = this.chunk.GetNeighbor(2);
								else if (neighborPosX >= this.chunkSize[0])
									neighborChunk = this.chunk.GetNeighbor(0);
								else if (neighborPosZ < 0)
									neighborChunk = this.chunk.GetNeighbor(1);
								else if (neighborPosZ >= this.chunkSize[2])
									neighborChunk = this.chunk.GetNeighbor(3);

								if (neighborChunk == this.chunk)
								{
									neighborBlock = this.chunk.GetBlockAtLocalPosition(neighborPosX, neighborPosY, neighborPosZ);
								}
								else if (neighborChunk != null)
								{
									neighborBlock = neighborChunk.GetBlockAtLocalPosition(
										MathUtils.Mod(neighborPosX, this.chunkSize[0]),
										neighborPosY,
										MathUtils.Mod(neighborPosZ, this.chunkSize[2])
									);
								}
							}

							if (blockModelBuffer == null || blockModelBuffer.Id != block)
								this.blockModelBuffer = this.blockService.GetBlockModel(block);

							if (neighborBlock > 0)
							{

								if (neighborBlock == block)
								{
									if (blockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
								else
								{
									if (neighborBlockModelBuffer == null || neighborBlockModelBuffer.Id != neighborBlock)
										this.neighborBlockModelBuffer = this.blockService.GetBlockModel(neighborBlock);

									if (neighborBlockModelBuffer.RenderType == RenderType.Opaque || block == neighborBlock && blockModelBuffer.HideConnectingFaces) continue;
								}
							}



							MeshBuffer activeMeshBuffer = blockModelBuffer.RenderType == RenderType.Transparent
								? this.transparentMeshBuffer
								: this.cutoutMeshBuffer;

							BlockMeshModel.GetFaceVerticesInWorldSpace(x, y, z, i, ref faceVerticesArrayBuffer);
							activeMeshBuffer.AddVertices(faceVerticesArrayBuffer);

							BlockMeshModel.GetFaceUVs(blockModelBuffer.TextureIndexes[i], ref faceUVsArrayBuffer);
							activeMeshBuffer.AddUVs(faceUVsArrayBuffer);

							activeMeshBuffer.GetVertexCount(out int activeMeshBufferVertexCount);
							for (int j = 0; j < BlockMeshModel.FaceTriangleOrder.Length; j++)
							{
								activeMeshBuffer.AddTriangle(activeMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
							}

							if (blockModelBuffer.Solid)
							{
								collisionMeshBuffer.AddVertices(faceVerticesArrayBuffer);

								collisionMeshBuffer.GetVertexCount(out int collisionMeshBufferVertexCount);
								for (int j = 0; j < BlockMeshModel.FaceTriangleOrder.Length; j++)
								{
									collisionMeshBuffer.AddTriangle(collisionMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
								}
							}
							else
							{
								// non solid blocks are double-sided
								activeMeshBuffer.AddVertices(faceVerticesArrayBuffer);

								activeMeshBuffer.AddUVs(faceUVsArrayBuffer);

								activeMeshBuffer.GetVertexCount(out activeMeshBufferVertexCount);
								for (int j = BlockMeshModel.FaceTriangleOrder.Length - 1; j >= 0; j--)
								{
									activeMeshBuffer.AddTriangle(activeMeshBufferVertexCount - 1 - BlockMeshModel.FaceTriangleOrder[j]);
								}

							}
						}
					}
				}
			}

			this.cutoutMeshBuffer.Rebuild();
			this.transparentMeshBuffer.Rebuild();
			this.collisionMeshBuffer.Rebuild();

			this.meshInvalidated = false;
		}
	}
}
